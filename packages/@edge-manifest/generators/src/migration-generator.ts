import type { EdgeManifest, ManifestEntity, ManifestField } from '@edge-manifest/core';

export interface MigrationGenerateOptions {
  version?: string;
  timestamp?: string;
}

/**
 * Generates SQL migration from manifest.
 */
export async function generateMigrations(
  manifest: EdgeManifest,
  options: MigrationGenerateOptions = {},
): Promise<string> {
  const timestamp = options.timestamp ?? new Date().toISOString();
  const version = options.version ?? generateVersion();
  const header = generateMigrationHeader(version, timestamp);
  const tables = manifest.entities.map((entity) => generateCreateTable(entity)).join('\n\n');
  const indexes = manifest.entities.flatMap((entity) => generateIndexes(entity)).join('\n');

  return `${header}\n\n${tables}\n\n${indexes}`;
}

function generateVersion(): string {
  return `${Date.now()}`;
}

function generateMigrationHeader(version: string, timestamp: string): string {
  return `-- Migration: ${version}\n-- Timestamp: ${timestamp}\n-- Generated by EDGE-MANIFEST`;
}

function generateCreateTable(entity: ManifestEntity): string {
  const tableName = entity.table || entity.name.toLowerCase();
  const fields = entity.fields
    .filter((field) => field.kind !== 'relation')
    .map((field) => generateSQLField(field))
    .join(',\n  ');

  const timestamps = 'created_at TEXT DEFAULT CURRENT_TIMESTAMP,\n  updated_at TEXT DEFAULT CURRENT_TIMESTAMP';

  return `CREATE TABLE IF NOT EXISTS ${tableName} (\n  ${fields},\n  ${timestamps}\n);`;
}

function generateSQLField(field: ManifestField): string {
  if (field.kind === 'relation') {
    throw new Error('Relations should be filtered out');
  }

  let sqlType = '';
  let constraints = '';

  switch (field.kind) {
    case 'id':
    case 'uuid':
      sqlType = 'TEXT';
      constraints = 'PRIMARY KEY NOT NULL';
      break;

    case 'string':
      sqlType = 'TEXT';
      break;

    case 'number':
      sqlType = 'REAL';
      break;

    case 'boolean':
      sqlType = 'INTEGER';
      break;

    case 'date':
      sqlType = 'TEXT';
      break;

    case 'json':
      sqlType = 'TEXT';
      break;

    default:
      throw new Error(`Unsupported field kind: ${(field as any).kind}`);
  }

  if (field.required && field.kind !== 'id' && field.kind !== 'uuid') {
    constraints += ' NOT NULL';
  }

  if (field.unique && field.kind !== 'id' && field.kind !== 'uuid') {
    constraints += ' UNIQUE';
  }

  if (field.default !== undefined && field.kind !== 'id' && field.kind !== 'uuid') {
    if (typeof field.default === 'string') {
      constraints += ` DEFAULT '${field.default}'`;
    } else if (typeof field.default === 'boolean') {
      constraints += ` DEFAULT ${field.default ? 1 : 0}`;
    } else {
      constraints += ` DEFAULT ${field.default}`;
    }
  }

  return `${field.name} ${sqlType}${constraints ? ` ${constraints.trim()}` : ''}`;
}

function generateIndexes(entity: ManifestEntity): string[] {
  const tableName = entity.table || entity.name.toLowerCase();
  const indexes: string[] = [];

  for (const field of entity.fields) {
    if (field.kind === 'relation') continue;

    if (field.unique && field.kind !== 'id' && field.kind !== 'uuid') {
      indexes.push(`CREATE UNIQUE INDEX IF NOT EXISTS idx_${tableName}_${field.name} ON ${tableName}(${field.name});`);
    }
  }

  return indexes;
}

/**
 * Generates a rollback migration
 */
export async function generateRollback(
  manifest: EdgeManifest,
  options: MigrationGenerateOptions = {},
): Promise<string> {
  const timestamp = options.timestamp ?? new Date().toISOString();
  const version = options.version ?? generateVersion();
  const header = generateMigrationHeader(`${version}_rollback`, timestamp);
  const drops = manifest.entities
    .map((entity) => {
      const tableName = entity.table || entity.name.toLowerCase();
      return `DROP TABLE IF EXISTS ${tableName};`;
    })
    .join('\n');

  return `${header}\n\n${drops}`;
}

/**
 * Generates migration metadata
 */
export function generateMigrationMetadata(manifest: EdgeManifest): {
  version: string;
  timestamp: string;
  entities: string[];
} {
  return {
    version: generateVersion(),
    timestamp: new Date().toISOString(),
    entities: manifest.entities.map((entity) => entity.name),
  };
}
